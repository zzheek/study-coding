public class Solution {
    public long solution(int n) {
        // n이 1이거나 2일 경우, 각각 1가지, 2가지 방법이 있음을 직접 반환
        if(n == 1) return 1;
        if(n == 2) return 2;
        
        // n이 3 이상일 경우를 대비하여, 초기 두 항의 값을 설정
        long[] dp = new long[n+1]; // n+1 크기의 배열 생성(0부터 시작하므로)
        dp[1] = 1; // 1번째 칸까지 도달하는 방법의 수는 1가지
        dp[2] = 2; // 2번째 칸까지 도달하는 방법의 수는 2가지
        
        // 3번째 칸부터 n번째 칸까지 각 칸에 도달하는 방법의 수를 계산
        for(int i=3; i<=n; i++) {
            // i번째 칸에 도달하는 방법의 수는 (i-1)번째 칸에 도달한 후 1칸을 뛰는 경우와
            // (i-2)번째 칸에 도달한 후 2칸을 뛰는 경우의 합
            dp[i] = (dp[i-1] + dp[i-2]) % 1234567; // 중간 계산에서도 값이 커지는 것을 방지하기 위해 모듈로 연산을 적용
        }
        
        // n번째 칸에 도달하는 방법의 수를 1234567로 나눈 나머지를 반환
        return dp[n];
    }
}
